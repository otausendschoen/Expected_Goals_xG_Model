xlab = "Pass Distance (meters)",
col = "lightblue", border = "white")
avg_shot_distance_by_year <- shots %>%
group_by(season_name) %>%
summarise(
avg_shot_distance = mean(shot_distance, na.rm = TRUE),
shot_count = n()
) %>%
filter(!is.na(season_name))
ggplot(avg_shot_distance_by_year, aes(x = season_name, y = avg_shot_distance, group = 1)) +
geom_line(size = 1.2, color = "darkred") +
geom_point(size = 2, color = "black") +
geom_smooth(method = "loess", se = FALSE, color = "steelblue", linetype = "dashed") +
labs(
title = "Average Shot Distance Over Time",
x = "Season",
y = "Average Distance to Goal (in pitch units)"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
avg_pass_distance_by_year <- passes %>%
group_by(season_name) %>%
summarise(
avg_pass_distance = mean(pass_distance, na.rm = TRUE),
pass_count = n()
) %>%
filter(!is.na(season_name))
ggplot(avg_pass_distance_by_year, aes(x = season_name, y = avg_pass_distance, group = 1)) +
geom_line(size = 1.2, color = "darkgreen") +
geom_point(size = 2, color = "black") +
geom_smooth(method = "loess", se = FALSE, color = "steelblue", linetype = "dashed") +
labs(
title = "Average Pass Distance Over Time",
x = "Season",
y = "Average Pass Distance (m)"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(shots, aes(x = shot_distance)) +
geom_density(fill = "lightblue") +
facet_wrap(~season_name) +  # no `scales = "free_y"`
labs(
title = "Distribution of Shot Distances per Season",
x = "Shot Distance (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 6),
strip.text = element_text(size = 8)
)
ggplot(passes, aes(x = pass_distance)) +
geom_density(fill = "lightblue") +
facet_wrap(~season_name) +
labs(
title = "Distribution of Pass Distances per Season",
x = "Pass Distance (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 6),
strip.text = element_text(size = 8)
)
# Get all available competitions
Comps <- FreeCompetitions()
# Filter only FIFA World Cup (male)
Comps <- Comps %>%
filter(competition_name == "FIFA World Cup", competition_gender == "male", season_name %in% c("1970", "2022"))
# Get all matches for the FIFA World Cup
Matches <- FreeMatches(Comps)
# Download all event data for these matches
StatsBombData <- free_allevents(MatchesDF = Matches, Parallel = T)
# Clean the data
StatsBombData <- allclean(StatsBombData)
# Filter only shots from StatsBombData
shots_wc   <- StatsBombData %>% filter(type.name == "Shot")
passes_wc  <- StatsBombData %>% filter(type.name == "Pass")
#Joined competetion to get seasons (for year analysis)
#Joined shots with competions, to obtain seasons
shots_wc   <- shots_wc %>% left_join(Comps, by = c("competition_id", "season_id"))
#Joined passes with competions, to obtain seasons
passes_wc  <- passes_wc %>%left_join(Comps, by = c("competition_id", "season_id"))
# Ensure shot locations are within pitch boundaries
heatmap <- shots_wc %>%
mutate(
location.x = pmax(0, pmin(120, location.x)),
location.y = pmax(0, pmin(80, location.y))
) %>%
mutate(
xbin = cut(location.x, breaks = seq(0, 120, by = 10), include.lowest = TRUE, labels = FALSE),
ybin = cut(location.y, breaks = seq(0, 80, by = 10), include.lowest = TRUE, labels = FALSE)
)
# Aggregate shots by bin and season
heatmap_summary <- heatmap %>%
group_by(xbin, ybin, season_name) %>%
summarise(
shot_count = n(),
location.x = (xbin - 1) * 10 + 5,  # Center each bin
location.y = (ybin - 1) * 10 + 5,
.groups = "drop"
)
ggplot(data = heatmap_summary, aes(x = location.x, y = location.y, fill = shot_count)) +
geom_tile(width = 10, height = 10, alpha = 0.9, color = "black") +
# Pitch
annotate("rect", xmin = 0, xmax = 120, ymin = 0, ymax = 80, fill = NA, colour = "black", size = 0.6) +
annotate("rect", xmin = 18, xmax = 0, ymin = 18, ymax = 62, fill = NA, colour = "black", size = 0.6) +
annotate("rect", xmin = 102, xmax = 120, ymin = 18, ymax = 62, fill = NA, colour = "black", size = 0.6) +
annotate("segment", x = 60, xend = 60, y = 0, yend = 80, colour = "black", size = 0.6) +
annotate("point", x = 60, y = 40, colour = "black", size = 1.5) +
annotate(
"path",
x = 60 + 10 * cos(seq(0, 2 * pi, length.out = 100)),
y = 40 + 10 * sin(seq(0, 2 * pi, length.out = 100)),
colour = "black", size = 0.6
) +
scale_fill_gradient(low = "blue", high = "red") +
scale_y_reverse() +
labs(
title = "Shot Density Map 1970-2022",
subtitle = "All Shots â€“ FIFA World Cup"
) +
coord_fixed(ratio = 95 / 100) +
facet_wrap(~season_name, ncol=2) +
theme_minimal()+
theme(
axis.text.x = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
legend.title = element_blank(),
legend.position = "bottom",  # Move legend below plot
plot.background = element_rect(fill = "white"),
panel.grid = element_blank(),
axis.ticks = element_blank(),
plot.margin = margin(1, 1, 1, 1),
strip.text = element_text(size = 12, face = "bold")  # Bigger facet titles
)
# Filter shots from Lionel Messi inside the box
shots.messi <- shots_wc %>%
filter(
type.name == "Shot",
player.id == 5503  # Lionel Messi's ID
) %>%
mutate(
goal = ifelse(shot.outcome.name == "Goal", "Goal", "Missed")  # Define goal/miss categories
)
# Plot pitch with colored shots
create_Pitch() +
geom_segment(
data = shots.messi,
aes(
x = location.x,
y = location.y,
xend = shot.end_location.x,
yend = shot.end_location.y,
color = goal  # Color by goal/miss
),
lineend = "round",
size = 0.5,
arrow = arrow(length = unit(0.07, "inches"), ends = "last", type = "open")
) +
# Define colors for shot outcomes
scale_color_manual(values = c("Goal" = "red", "Missed" = "blue")) +
# Labels and formatting
labs(
title = "Lionel Messi",
subtitle = "FIFA World Cup Shots, 2002",
color = "Shot Outcome"
) +
# Adjust field proportions
scale_y_reverse() +
coord_fixed(ratio = 105 / 100)+
theme(
plot.margin = margin(1, 1, 1, 1),
legend.position = "bottom",  # Places legend below
legend.title = element_text(face = "bold"),  # Bold legend title
legend.key.width = unit(2.5, "cm"),  # Adjust legend size
legend.text = element_text(size = 10)  # Set legend text size,
)
# Set team of interest
selected.team <- "Brazil"
# Define Expected Goals color scale
shotmapxgcolors <- c("#192780", "#2a5d9f", "#40a7d0", "#87cdcf", "#e7f8e6",
"#f4ef95", "#FDE960", "#FCDC5F", "#F5B94D", "#F0983E",
"#ED8A37", "#E66424", "#D54F1B", "#DC2608", "#BF0000",
"#7F0000", "#5F0000")
# Filter shots for selected team (excluding penalties)
shots.brazil <- shots_wc %>%
filter((shot.type.name != "Penalty" | is.na(shot.type.name)) &
team.name == selected.team  & season_name %in% c("1970", "2022")) %>%
dplyr::select(location.x, location.y, shot.statsbomb_xg, shot.body_part.name, season_name)
# Plot
ggplot() +
# Draw pitch
annotate("rect", xmin = 0, xmax = 120, ymin = 0, ymax = 80, fill = NA, colour = "black", size = 0.6) +
annotate("rect", xmin = 18, xmax = 0, ymin = 18, ymax = 62, fill = NA, colour = "black", size = 0.6) +
annotate("rect", xmin = 102, xmax = 120, ymin = 18, ymax = 62, fill = NA, colour = "black", size = 0.6) +
annotate("point", x = 108, y = 40, colour = "black", size = 1.05) +  # Penalty spot
annotate("point", x = 60, y = 40, colour = "black", size = 1.05) +   # Center spot
# Plot shots
geom_point(data = shots.brazil,
aes(x = location.x, y = location.y, fill = shot.statsbomb_xg, shape = shot.body_part.name),
size = 2, alpha = 0.8) +
# Color and shape scales
scale_fill_gradientn(colours = shotmapxgcolors, limits = c(0, 0.8), oob = scales::squish, name = "Expected Goals") +
scale_shape_manual(values = c("Head" = 21, "Right Foot" = 23, "Left Foot" = 24), name = "Body Part") +
# Facet by season
facet_wrap(~ season_name) +
# Labels and theme
labs(title = paste(selected.team, "Shot Maps"),
subtitle = "FIFA World Cup, Different Years") +
theme_minimal() +
theme(
legend.position = "top",
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
plot.subtitle = element_text(size = 10, hjust = 0.5),
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
plot.margin = margin(1,1,1,1),
aspect.ratio = 65 / 100
) +
coord_flip(xlim = c(85, 125))
xg_df <- shots %>%
dplyr::select(shot.outcome.name,
play_pattern.name,
under_pressure,
location.x,
location.y,
shot_distance,
shot.technique.name,
shot.body_part.name,
shot.type.name,
shot.aerial_won,
shot.follows_dribble,
shot.first_time,
shot.open_goal,
shot.is_assisted,
#location.x.GK,
#location.y.GK,
angle_to_goal,
competition_name,
season_name,
team.name,
player.name
) %>%
mutate(is_goal = shot.outcome.name == "Goal") %>%  # creates TRUE/FALSE
dplyr::select(is_goal, everything(), -shot.outcome.name)  # moves is_goal to the first column
xg_df <- xg_df %>%
mutate(is_shot_foot = if_else(shot.body_part.name %in% c("Right Foot", "Left Foot"), TRUE, FALSE)) %>%
relocate(is_shot_foot, .after = shot.body_part.name) %>%
dplyr::select(-shot.body_part.name)
insert_one_hot <- function(df, col_name) {
# Create dummy variables (as a data frame)
dummies <- as.data.frame(model.matrix(~ . - 1, data = df[col_name]))
# Clean up column names
colnames(dummies) <- gsub(paste0("^", col_name), col_name, colnames(dummies))
colnames(dummies) <- gsub(" ", ".", colnames(dummies))  # Replace spaces if needed
# Get the original column position
pos <- which(names(df) == col_name)
# Build new df: before, dummies, after
df_new <- bind_cols(
df[1:(pos - 1)],
dummies,
df[(pos + 1):ncol(df)]
)
return(df_new)
}
xg_df_encoded <- xg_df  # make a copy to preserve original
cols_to_encode <- c("play_pattern.name", "shot.technique.name", "shot.type.name")
for (col in cols_to_encode) {
xg_df_encoded <- insert_one_hot(xg_df_encoded, col)
}
xg_df_encoded <- xg_df_encoded %>%
mutate(across(where(is.logical), ~ if_else(is.na(.), FALSE, .)))
set.seed(42)  # for reproducibility
# Create an 70/30 train-test split based on the is_goal variable
train_index <- createDataPartition(xg_df_encoded$is_goal, p = 0.7, list = FALSE)
train_data <- xg_df_encoded[train_index, ]
test_data  <- xg_df_encoded[-train_index, ]
# Fit logistic regression on the training set
model_distance <- glm(is_goal ~ shot_distance, data = train_data, family = binomial)
# Summarize the model
summary(model_distance)
# Fit logistic regression on the training set (now adding angle)
model_distance_and_angle <- glm(is_goal ~ shot_distance + angle_to_goal, data = train_data, family = binomial)
# Summarize the model
summary(model_distance_and_angle)
AIC(model_distance, model_distance_and_angle)
anova(model_distance, model_distance_and_angle, test = "Chisq")
# Fit logistic regression on the training set (now adding whether the shot was under pressure)
model_distance_and_angle_and_pressure <- glm(is_goal ~ shot_distance + angle_to_goal + under_pressure, data = train_data, family = binomial)
# Summarize the model
summary(model_distance_and_angle_and_pressure)
AIC(model_distance, model_distance_and_angle, model_distance_and_angle_and_pressure)
anova(model_distance, model_distance_and_angle, model_distance_and_angle_and_pressure, test = "Chisq")
model_descriptive <- glm(is_goal ~
shot_distance +
angle_to_goal +
is_shot_foot +
under_pressure +
shot.is_assisted
, data = train_data, family = binomial)
# Summarize the model
summary(model_descriptive)
AIC(model_distance_and_angle_and_pressure, model_descriptive)
anova(model_distance_and_angle_and_pressure, model_descriptive, test = "Chisq")
# Predict on the test set (get predicted probabilities)
predicted_probs <- predict(model_descriptive, newdata = test_data, type = "response")
# Create a prediction data frame covering the range of shot distances
pred_data <- data.frame(shot_distance = seq(min(train_data$shot_distance, na.rm = TRUE),
max(train_data$shot_distance, na.rm = TRUE),
length.out = 100))
pred_data$pred_prob <- predict(model_distance, newdata = pred_data, type = "response")
# Plot the relationship between shot distance and predicted probability
ggplot(pred_data, aes(x = shot_distance, y = pred_prob)) +
geom_line(color = "blue") +
labs(title = "Predicted Goal Probability vs. Shot Distance",
x = "Shot Distance from the Goal (Meters)",
y = "Predicted Probability of Scoring") +
theme_minimal()
# Filter for EPL 2015/16 and compute predicted xG using your model_descriptive
premier_df_team <- xg_df_encoded %>%
filter(competition_name == "England - Premier League", season_name == "2015/2016") %>%
mutate(predicted_xg = predict(model_descriptive, newdata = ., type = "response"))
# Aggregate the data to sum actual goals and expected goals for the season per team.
# Using as.numeric(is_goal) converts TRUE to 1 and FALSE to 0 on the fly.
team_summary <- premier_df_team %>%
group_by(team.name) %>%
summarise(
actual_goals = sum(as.numeric(is_goal), na.rm = TRUE),
expected_goals = sum(predicted_xg, na.rm = TRUE)
) %>%
arrange(desc(actual_goals))
# View the summary table
print(team_summary)
# Plot Actual vs Expected Goals for each team
ggplot(team_summary, aes(x = expected_goals, y = actual_goals, label = team.name)) +
geom_point(color = "lightseagreen", size = 3) +
geom_text_repel(
size = 3,
max.overlaps = 15,
box.padding = 0.35,
point.padding = 0.5
) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey50") +
labs(
title = "Actual Goals vs Expected Goals (xG) in 2015/16 EPL",
x = "Expected Goals (xG)",
y = "Actual Goals"
) +
theme_minimal(base_size = 12)
# Filter for Premier League 2015/16 shots and generate predictions
premier_df_player <- xg_df_encoded %>%
filter(competition_name == "England - Premier League", season_name == "2015/2016") %>%
mutate(predicted_xg = predict(model_descriptive, newdata = ., type = "response"))
# Aggregate the data at the player level
player_summary <- premier_df_player %>%
group_by(player.name) %>%  # Grouping by player name and ID
summarise(
actual_goals = sum(as.numeric(is_goal), na.rm = TRUE),
expected_goals = sum(predicted_xg, na.rm = TRUE),
shots = n()
) %>%
arrange(desc(actual_goals))
# View the summary table
print(player_summary)
ggplot(player_summary, aes(x = expected_goals, y = actual_goals, label = player.name)) +
# Use a softer green color, e.g., "forestgreen" or "palegreen4"
geom_point(color = "lightseagreen", size = 3) +
# Use geom_text_repel to minimize overlapping labels
geom_text_repel(
size = 3,
max.overlaps = 15,   # controls how many labels can overlap before some are omitted
box.padding = 0.35,  # space around the text box
point.padding = 0.5  # space around the point
) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey50") +
labs(
title = "Actual Goals vs Expected Goals (xG) by Player in 2015/16 Premier League",
x = "Total Expected Goals (xG)",
y = "Total Actual Goals"
) +
theme_minimal(base_size = 12)  # Increase base font size if desired
# Filter for La Liga 2015/16 and compute predicted xG using your model_descriptive
la_liga_df_team <- xg_df_encoded %>%
filter(competition_name == "Spain - La Liga", season_name == "2015/2016") %>%
mutate(predicted_xg = predict(model_descriptive, newdata = ., type = "response"))
# Aggregate the data to sum actual goals and expected goals for the season per team.
# Using as.numeric(is_goal) converts TRUE to 1 and FALSE to 0 on the fly.
team_summary <- la_liga_df_team %>%
group_by(team.name) %>%
summarise(
actual_goals = sum(as.numeric(is_goal), na.rm = TRUE),
expected_goals = sum(predicted_xg, na.rm = TRUE)
) %>%
arrange(desc(actual_goals))
# View the summary table
print(team_summary)
# Plot Actual vs Expected Goals for each team
ggplot(team_summary, aes(x = expected_goals, y = actual_goals, label = team.name)) +
geom_point(color = "lightseagreen", size = 3) +
geom_text_repel(
size = 3,
max.overlaps = 15,
box.padding = 0.35,
point.padding = 0.5
) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey50") +
labs(
title = "Actual Goals vs Expected Goals (xG) in 2015/16 Spanish La Liga",
x = "Expected Goals (xG)",
y = "Actual Goals"
) +
theme_minimal(base_size = 12)
# Filter for La Liga 2015/16 shots and generate predictions
la_liga_df_player <- xg_df_encoded %>%
filter(competition_name == "Spain - La Liga", season_name == "2015/2016") %>%
mutate(predicted_xg = predict(model_descriptive, newdata = ., type = "response"))
# Aggregate the data at the player level
player_summary <- la_liga_df_player %>%
group_by(player.name) %>%  # Grouping by player name and ID
summarise(
actual_goals = sum(as.numeric(is_goal), na.rm = TRUE),
expected_goals = sum(predicted_xg, na.rm = TRUE),
shots = n()
) %>%
arrange(desc(actual_goals))
# View the summary table
print(player_summary)
ggplot(player_summary, aes(x = expected_goals, y = actual_goals, label = player.name)) +
# Use a softer green color, e.g., "forestgreen" or "palegreen4"
geom_point(color = "lightseagreen", size = 3) +
# Use geom_text_repel to minimize overlapping labels
geom_text_repel(
size = 3,
max.overlaps = 15,   # controls how many labels can overlap before some are omitted
box.padding = 0.35,  # space around the text box
point.padding = 0.5  # space around the point
) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey50") +
labs(
title = "Actual Goals vs Expected Goals (xG) by Player in 2015/16 Spanish La Liga",
x = "Total Expected Goals (xG)",
y = "Total Actual Goals"
) +
theme_minimal(base_size = 12)  # Increase base font size if desired
# Filter for La Liga 2015/16 and compute predicted xG using your model_descriptive
world_cup_df_team <- xg_df_encoded %>%
filter(competition_name == "International - FIFA World Cup", season_name == "2022") %>%
mutate(predicted_xg = predict(model_descriptive, newdata = ., type = "response"))
# Aggregate the data to sum actual goals and expected goals for the season per team.
# Using as.numeric(is_goal) converts TRUE to 1 and FALSE to 0 on the fly.
team_summary <- world_cup_df_team %>%
group_by(team.name) %>%
summarise(
actual_goals = sum(as.numeric(is_goal), na.rm = TRUE),
expected_goals = sum(predicted_xg, na.rm = TRUE)
) %>%
arrange(desc(actual_goals))
# View the summary table
print(team_summary)
# Plot Actual vs Expected Goals for each team
ggplot(team_summary, aes(x = expected_goals, y = actual_goals, label = team.name)) +
geom_point(color = "lightseagreen", size = 3) +
geom_text_repel(
size = 3,
max.overlaps = 15,
box.padding = 0.35,
point.padding = 0.5
) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey50") +
labs(
title = "Actual Goals vs Expected Goals (xG) in 2022 FIFA World Cup",
x = "Expected Goals (xG)",
y = "Actual Goals"
) +
theme_minimal(base_size = 12)
# Filter for La Liga 2015/16 shots and generate predictions
world_cup_df_player <- xg_df_encoded %>%
filter(competition_name == "International - FIFA World Cup", season_name == "2022") %>%
mutate(predicted_xg = predict(model_descriptive, newdata = ., type = "response"))
# Aggregate the data at the player level
player_summary <- world_cup_df_player %>%
group_by(player.name) %>%  # Grouping by player name and ID
summarise(
actual_goals = sum(as.numeric(is_goal), na.rm = TRUE),
expected_goals = sum(predicted_xg, na.rm = TRUE),
shots = n()
) %>%
arrange(desc(actual_goals))
# View the summary table
print(player_summary)
ggplot(player_summary, aes(x = expected_goals, y = actual_goals, label = player.name)) +
# Use a softer green color, e.g., "forestgreen" or "palegreen4"
geom_point(color = "lightseagreen", size = 3) +
# Use geom_text_repel to minimize overlapping labels
geom_text_repel(
size = 3,
max.overlaps = 15,   # controls how many labels can overlap before some are omitted
box.padding = 0.35,  # space around the text box
point.padding = 0.5  # space around the point
) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey50") +
labs(
title = "Actual Goals vs Expected Goals (xG) in 2022 FIFA World Cup",
x = "Total Expected Goals (xG)",
y = "Total Actual Goals"
) +
theme_minimal(base_size = 12)  # Increase base font size if desired
